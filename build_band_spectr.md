# `build_band_spectr(spec, out_buf)` — опис алгоритму та параметрів

Цей блок перетворює **FFT-спектр** (енергії бінів) у **16 смуг** для LED-матриці: кожна смуга отримує рівень **0..16** (0 — вимкнено, 1..16 — висота стовпця).

---

## Вхід / вихід

### Вхід
- `spec` — результат `rfft` (масив бінів). Очікується, що `spec[k] ≥ 0` і відображає **енергію/потужність** біну `k`.
- Константи:
  - `IND_BANDS` — розбиття бінів на 16 смуг (кількість бінів у кожній смузі).
  - `NOISE_THRESHOLD` — пороги шуму **по смугах**.
  - `FS_RMS2` — опорна потужність повномасштабного синуса (RMS²), у вас: `32767**2 / 2`.

### Вихід
- `out_buf` — `bytearray(16)` або інший байтовий буфер довжини 16:
  - `out_buf[i] = 0` → смуга нижче шумового порогу (LED погашено)
  - `out_buf[i] = 1..16` → висота стовпця

---

## Основні етапи роботи

### 1) Об’єднання FFT-бінів у смуги (`IND_BANDS`)
Смуга `i` охоплює діапазон бінів `[ind, ind + w)`, де `w = IND_BANDS[i]`, а `ind` накопичується.

**Навіщо:** робимо 512 (або іншу кількість) бінів FFT керованою кількістю смуг (тут 16) і стабілізуємо індикацію.

---

### 2) Перехід у dBFS (`band_dbfs`)
Для смуги рахується:
- `e = sum(spec[k])` по бінах смуги
- якщо `e <= 0`, повертаємо умовний мінімум (наприклад, `-120 dBFS`)
- інакше:

\[
dbfs = 10 \log_{10}\left(\frac{2e}{FS\_RMS2}\right)
\]

Примітка: множник `2e` — поправка для one-sided спектра (rfft дає половину спектра).

---

### 3) Порогова обробка шуму (`NOISE_THRESHOLD`)
Порогова логіка робить значення **позитивним “наскільки dB над шумом”**:

- трактування: `NOISE_THRESHOLD[i]` — це `|noise_dbfs|`, тобто поріг шуму в dBFS:
  - `noise_dbfs[i] = -NOISE_THRESHOLD[i]`

- перетворення:
\[
adj_i = \max(0, dbfs - noise\_dbfs) = \max(0, dbfs + NOISE\_THRESHOLD[i])
\]

`adj_i` — це **dB над порогом** (невід’ємне число).

**Навіщо:** при тиші/шумі смуги стають 0 і не “живуть” випадково.

---

### 4) Динамічний масштаб (AGC по смугах)
Знаходимо пік по смугах:
\[
peak\_adj = \max_i(adj_i)
\]

Далі будуємо “ціль” масштабу з запасом:
\[
target = peak\_adj + HEADROOM\_DB
\]

І підтримуємо стан масштабу `_scale_db` (в dB над порогом), з двома режимами:

- **attack (швидко вгору):**
  - якщо `target > _scale_db`, то `_scale_db = target`
- **release (повільно вниз):**
  - якщо `target <= _scale_db`, то `_scale_db` зменшується на `SCALE_DECAY_DB` за кадр,
  - але не нижче `target` і не нижче `SCALE_MIN_DB`.

**Інтерпретація:** `_scale_db` — це “скільки dB над порогом відповідає верхній межі шкали”.

---

### 5) Нормування та нелінійність (`GAMMA`)
Для кожної смуги:
\[
x = \mathrm{clamp}(adj_i / _scale\_db, 0..1)
\]
\[
y = x^{GAMMA}
\]

- `GAMMA < 1` піднімає низ (тихі смуги стають помітніші).
- `GAMMA = 1` лінійно.
- `GAMMA > 1` пригнічує низ.

---

### 6) Квантування у рівні 0..16
Типовий варіант (із округленням) для ненульових смуг:
\[
lvl = 1 + \lfloor 15y + 0.5 \rfloor
\]
Після чого клемп `lvl` у `1..16`.

- Якщо `adj_i == 0` → `out_buf[i] = 0`
- Інакше → `out_buf[i] = lvl` (1..16)

---

## Параметри та їхній вплив

### `IND_BANDS` (16 значень)
**Впливає на** частотну роздільність:
- більше бінів у смузі → більш гладка індикація, менше “смикання”
- менше бінів → вища роздільність, але більше шуму/варіацій

---

### `NOISE_THRESHOLD[i]` (16 значень)
Порог для кожної смуги (у dBFS, через знак):
- `noise_dbfs[i] = -NOISE_THRESHOLD[i]`

**Більше `NOISE_THRESHOLD` → нижчий поріг (більш чутливо).**  
Напр.: 90 → поріг -90 dBFS (дуже чутливо), 50 → поріг -50 dBFS (менш чутливо).

---

### `HEADROOM_DB`
Запас над піком для масштабу.

- **Збільшити** → верхні рівні досягаються рідше, менше “залипання” на 16, стабільніше.
- **Зменшити** → 16 досягається частіше (агресивніша шкала).

---

### `SCALE_DECAY_DB`
Швидкість зменшення `_scale_db` при затиханні (release).

- **Більше** → швидше “відпускає” масштаб, індикатор швидше оживає після гучного піку, але більше “пампінгу”.
- **Менше** → плавніше, стабільніше, але після піку може бути короткий період “приглушення”.

---

### `SCALE_MIN_DB`
Нижня межа масштабу `_scale_db`.

- **Більше** → менш чутливо (потрібно більше dB над порогом для видимого рівня).
- **Менше** → більш чутливо (ризик підняти шум, якщо `NOISE_THRESHOLD` слабкий).

---

### `GAMMA`
Нелінійна компресія (візуальна “крива”):

- `GAMMA = 0.5..0.8` — піднімає тихі смуги (часто корисно для музики).
- `GAMMA ≈ 1.0` — лінійно.
- `GAMMA > 1.0` — робить індикатор більш “контрастним” (тихе майже зникає).

---

## Практичний порядок підлаштування

1) **`NOISE_THRESHOLD[]`**: при тиші більшість смуг мають бути 0 (або дуже рідкі 1).  
2) **`HEADROOM_DB`**: визначає, як часто індикатор торкається 16.  
3) **`SCALE_DECAY_DB`**: прибирає/додає “пампінг” при зміні гучності.  
4) **`GAMMA`**: підлаштовує вигляд низу (тихих смуг) без зміни порогів.

---

## Примітки для 2-потокового конвеєра

- `build_band_spectr()` працює на Core0 (DSP), результат пише в `spec_back`.
- Core1 має працювати тільки з `spec_front/max_front` (або локальними work-буферами) і викликати `viper + np.write()`.
- Для режиму `_thread: unsafe` важливо уникати спільного доступу до mutable об’єктів без `lock`.
